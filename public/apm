#!/bin/bash

# Awesome Package Manager
# apm is a simple script to manage diss server/agent packages, you can install/uninstall/setup server/agent
# service through this script

# set -e

usage() {
    echo ""
    echo "Simple script for managing diss server/agent package"
    echo ""
    echo "Usage: apm command [options]"
    echo "Commands:"
    echo "  install     install server/agent service, script will recognize automatically which module is about to install"
    echo "  uninstall   uninstall server/agent service, all containers, images and data will be removed"
    echo "  setup       setup configure server's ip/domain"
    echo ""
    echo "General Options:"
    echo "  --path path  specify install directory (default: /opt)"
    echo "  --module module specify module to manage, accept server or agent (default: agent)"
    echo "  --host address specify server's ip/domain. script will ask you to input address value if this agument is not"
    echo "                 specified for command install and setup"
    echo "  --help, -h   show help text"
    echo ""
    echo "Install Options:"
    echo "  --url  url   specify server/agent release package url, can be ssh://user@host:/example/diss-agent[server]-2.2.1.3.tar.gz" 
    echo "               or https://example.com/pacakges/diss-agent[server]-2.2.1.3.tar.gz or file:///opt/diss-agent[server]-2.2.1.3.tar.gz"
    echo ""
}

check_dependency() {
    if ! hash docker > /dev/null; then
        echo "APM ${command} ${module} requires docker"
        exit 1
    fi

    if ! hash docker-compose > /dev/null; then
        echo "APM ${command} ${module} requires docker-compose"
        exit 1
    fi

    if [[ $(docker version -f {{.Server.Version}}) =~ ([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
        local major=${BASH_REMATCH[1]}
        local minor=${BASH_REMATCH[2]}
        local patch=${BASH_REMATCH[3]}

        if [[ ${major} -lt 1 || (${major} -eq 1 && ${minor} -lt 12) ]]; then
            echo "APM ${command} ${module} requires a docker with version 1.12.0+"
            exit 1
        fi
    else
        echo "Parse docker version failed"
        exit 1
    fi

    # 1.20.0 add compatibility mode support
    if [[ $(docker-compose version --short) =~ ([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
        local major=${BASH_REMATCH[1]}
        local minor=${BASH_REMATCH[2]}
        local patch=${BASH_REMATCH[3]}

        if [[ ${major} -lt 1 || (${major} -eq 1 && ${minor} -lt 9) ]]; then
            echo "APM ${command} ${module} requires a docker-compose with version 1.9.0+"
            exit 1
        fi

        if [[ ${major} -lt 1 || (${major} -eq 1 && ${minor} -lt 20) ]]; then
            echo -e "\033[33mWarning\033[0m: docker-compose version below 1.20.0 is not support compatibility mode, docker-compose.yaml with version 2.0 will be used"
            compatibility=false
        fi
    fi
}

check_host() {
    if [ -f "/etc/os-release" ]; then
        . /etc/os-release
    elif [ -f "/lib/os-release" ]; then
        . /lib/os-release
    else
        ID=unknown
        VERSION_ID=unknown
        echo -e "\033[33mWarning\033[0m: found unknown platform, ${command} ${module} maybe fail"
    fi

    host_os_id=${ID}
    host_os_version=${VERSION_ID}
    host_arch=`uname -m`
    host_name=`hostname`

    echo ""
    echo "****************** Summary **************************"
    echo "              host: ${host_name}"
    echo "                os: ${host_os_id}:${host_os_version}"
    echo "              arch: ${host_arch}"
    echo "            docker: $(docker version -f {{.Server.Version}}) compose: $(docker-compose --version | awk -F, '{print $1}' | awk -F' ' '{print $NF}')"
    echo "****************************************************"
}

download_from_sshd() {
    url=${url:6}
    echo "Downloading ${module} package from ${url}"
    if ! scp ${url} /tmp/${package} > /dev/null; then
        echo "Download ${module} package from ${url} failed"
        exit 1
    fi
    echo "Download ${module} package from ${url} success"
}

download_from_http() {
    if ! hash curl > /dev/null; then
        echo "Curl is required for downloading ${module} package, please install curl first"
        exit 1
    fi

    echo "Downloading ${module} package from ${url}"
    if ! curl -ksL ${url} -o /tmp/${package} > /dev/null; then
        echo "Download ${module} package from ${url} failed"
        exit 1
    fi

    echo "Download ${module} package from ${url} success"
}

install_agent() {

    ## uninstall other version docker-bench-security and install new docker-bench-security
    uninstall_image docker-bench-security
    docker load -i "${install_prefix}/images/docker-bench.tar"
    [ $? -ne 0 ] && exit 1

    uninstall_image kube-bench
    docker load -i "${install_prefix}/images/kube-bench.tar"
    [ $? -ne 0 ] && exit 1

    ## install amclean image
    uninstall_image amclean
    docker load -i "${install_prefix}/images/amclean.tar"
    [ $? -ne 0 ] && exit 1

    ## install diss-metric image
    uninstall_image diss-metric
    docker load -i "${install_prefix}/images/diss-metric.tar"
    [ $? -ne 0 ] && exit 1

    ## install amprobe image
    uninstall_image amprobe
    docker load -i "${install_prefix}/images/amprobe.tar"
    [ $? -ne 0 ] && exit 1

    ## install diss-weave image
    uninstall_image scope
    docker load -i "${install_prefix}/images/scope.tar"
    [ $? -ne 0 ] && exit 1

    uninstall_image diss-kube-scan
    docker load -i "${install_prefix}/images/kube-scan.tar"
    [ $? -ne 0 ] && exit 1

    echo "path=${install_prefix}" > ${cfgpath}/diss-agent.conf

    if [ ${compatibility} = "false" ]; then
        if [ ! -f "${install_path}/diss-metric/docker-compose.2.yaml" ]; then
                echo "Cannot find docker-compose.yaml with version 2.0, please contact system provider for more support"
                exit 1
        fi
        
        sed -i 's/^docker-compose --compatibility \(.*\)$/docker-compose \1/' "${install_path}/dc"
        [ $? -ne 0 ] && echo "Switch docker-compose to support version 2.0 failed" && exit 1

        if ! cp "${install_path}/diss-metric/docker-compose.2.yaml" "${install_path}/docker-compose.yaml"; then
            echo "Cannot find docker-compose.yaml with version 2.0, please contact system provider for more support"
            exit 1
        fi
    fi

    if [ -f "${install_path}/docker-compose.yaml" ]; then 
	    version=`cat "${install_path}/docker-compose.yaml" | grep -E 'image:.*diss-metric:' | awk -F: '{print $3}'`
        echo "version=${version}" >> ${cfgpath}/diss-agent.conf
    fi

    setup

	echo "address=${address}" >> ${cfgpath}/diss-agent.conf

    setup_env
    setup_rpm

    echo "Install ${module} success"
}

install_server() {
    uninstall_image diss-backend
    docker load -i "${install_prefix}/images/diss-backend.tar.gz"
    [ $? -ne 0 ] && exit 1

    uninstall_image diss-ui-nginx
    docker load -i "${install_prefix}/images/diss-ui-nginx.tar.gz"
    [ $? -ne 0 ] && exit 1

    uninstall_image nats-streaming
    docker load -i "${install_prefix}/images/nats-streaming.tar.gz"
    [ $? -ne 0 ] && exit 1

    uninstall_image postgres
    docker load -i "${install_prefix}/images/postgres-9.tar.gz"
    [ $? -ne 0 ] && exit 1

    uninstall_image timescaledb
    docker load -i "${install_prefix}/images/timescaledb.tar.gz"
    [ $? -ne 0 ] && exit 1

    [ -d "/var/lib/diss/db" ] && rm -fr "/var/lib/diss/db"

    local upload_path=${cfgpath}/upload
    local asset_path=${install_path}/datapack
    local asset_file=`ls -c "${asset_path}/" | grep assets`
    asset_file="${asset_path}/`echo ${asset_file} | awk -F' ' '{print $1}'`"

    if [ -f "${asset_file}" ]; then
        echo "Install server required assets"

        if [ ! -d "${upload_path}" ]; then
            mkdir -p "${upload_path}"
        fi

        if ! tar zxf "${asset_file}" -C "${upload_path}"; then
            echo "Install server required assets failed"
            exit 1
        fi
    fi

    echo "path=${install_prefix}" > ${cfgpath}/diss-backend.conf

    if [ -f "${install_path}/diss-backend/docker-compose.yml" ]; then 
	    version=`cat "${install_path}/diss-backend/docker-compose.yml" | grep -E 'image:.*diss-backend:' | awk -F: '{print $3}'`
        echo "version=${version}" >> ${cfgpath}/diss-backend.conf
    fi

    setup

	echo "address=${address}" >> ${cfgpath}/diss-backend.conf

    echo "Install ${module} success"
}

install() {
    if [[ ${url} =~ ^http.* ]]; then
        download_from_http
    elif [[ ${url} =~ ^ssh.* ]]; then
        download_from_sshd
    else
        url=${url:7}
        cp ${url} /tmp/${package}
    fi

    local selinux=
    if hash getenforce > /dev/null; then
        selinux=`getenforce`
        if [ ${selinux} = "Enforcing" ]; then
            echo "Setting SELinux to Permissive mode"
            if ! setenforce Permissive > /dev/null; then
                echo "Set SELinux to Permissive mode failed"
                exit 1
            fi
        fi
    fi

    cleanup
    mkdir -p ${install_prefix}

    if ! tar zxf /tmp/${package} --strip-components=1 -C ${install_prefix} 2> /dev/null; then
        rm -f /tmp/${package}
        echo "Uncompress ${module} package(${package}) failed"
        exit 1
    fi

    # clear temporary package file
    rm -f /tmp/${package}

    if [ ! -d ${cfgpath}} ];then
        mkdir -p ${cfgpath}
        chmod 755 -R ${cfgpath}
    fi

    case ${module} in
        agent)
            install_agent
            ;;
        server)
            install_server
            ;;
    esac

    if [ -f "${install_path}/dc" ]; then
        if sh -c "${install_path}/dc up -d"; then
            echo "Running diss ${module} success"
        else
            echo "Running diss ${module} failed"
        fi
    else
        echo "Launch script ${install_path}/dc is not exist, skip running diss ${module}"
    fi
}

get_config() {
    if [ $# -eq 0 ]; then
        echo "Please specify a configure field to parse"
        exit 1
    fi

    local file=${cfgpath}/diss-agent.conf
    [ ${module} = "server" ] && file=${cfgpath}/diss-backend.conf

    [ ! -f "${file}" ] && return

    cat ${file} | grep $1 | awk -F= '{print $2}'
}

setup_db() {
    [ "${module}" != "server" ] && return


    if [ ! -d "${install_path}/datapack/init_data" ]; then
        echo -e "\033[33mWarning\033[0m: Skip initialzing database step, no valid initial data provided"
        return 0
    fi

    compatibility=`docker-compose --help 2> /dev/null | grep compatibility | awk -F' ' '{print $1}'`
    network=`docker network ls | grep diss-net-all`
    if [ -z "${network}" ]; then
        if ! docker network create diss-net-all; then
            echo "Unable to initialize database, create docker network diss-net-all failed"
            return 1
        fi
    fi

    if ! docker-compose ${compatibility} -f "${install_path}/diss-backend/docker-compose.yml" up -d diss-db; then
        echo "Unable to initialize database, start container diss-db failed"
        return 1
    fi

    local timeout=30
    local elapse=0
    while test ${elapse} -lt ${timeout}
    do
        if docker exec -t diss-db psql -h 127.0.0.1 -U diss -l > /dev/null 2>&1; then
            break
        fi
        elapse=$(($elapse+1))
        sleep 1
    done

    if [ ${elapse} -eq ${timeout} ]; then
        echo "Unable to initialize database, access database failed"
        return 1
    fi

    for file in `ls ${install_path}/datapack/init_data`
    do
        filepath=${install_path}/datapack/init_data/${file}
        if [[ "${filepath}" =~ .*.sql$ ]]; then
            if ! docker cp "${filepath}" diss-db:/opt; then
                echo "Unable to initialize ${file%.*}, copy initial data failed"
                return 1
            fi

            state=`docker exec -t diss-db psql -h 127.0.0.1 -U diss -d diss -f "/opt/${file}" | grep COPY | awk -F' ' '{if($2==0) print "false"; else print "true"}'`
            if [ "${state}" != "true" ]; then
                echo "Unable to initialize ${file%.*}, process initial data failed"
                return 1
            fi
        fi
    done

    docker-compose ${compatibility} -f "${install_path}/diss-backend/docker-compose.yml" stop diss-db > /dev/null
    docker rm -f diss-db > /dev/null
    docker network rm diss-net-all  > /dev/null
}

setup_env() {
    echo "Setup ${module} environments for root"
    export PROMPT_COMMAND='history -a'

    history_tmformat="%y/%m/%d %T "
    is_tmformat_set=`grep 'export HISTTIMEFORMAT="%y/%m/%d %T"' ${bashcfg} | wc -l`
    if [ ${is_tmformat_set} -eq 0 ]; then
        echo 'export HISTTIMEFORMAT="%y/%m/%d %T" 2>/dev/null' >> ${bashcfg}
    fi

    is_prompt_command=`grep 'export PROMPT_COMMAND="history -a"' ${bashcfg} | wc -l`
    if [ ${is_prompt_command} -eq 0 ]; then
        echo 'export PROMPT_COMMAND="history -a" 2>/dev/null' >> ${bashcfg}
    fi

    ## 改名现有的命令历史记录文件，以便之后的采集数据都有时间信息
    if [ -f ~/.bash_hisbakup ]; then
        echo "Rename bash_history backup file to ~/.bash_hisbakup${RANDOM}"
        mv ~/.bash_hisbakup ~/.bash_hisbakup${RANDOM}
    fi

    if [ -f ~/.bash_history ]; then
        mv ~/.bash_history ~/.bash_hisbakup
    fi
}

setup_agent() {
    sed -i 's/ServerUrl=.*/ServerUrl='${address}'/' "${install_path}/diss-metric/diss-metric.env"
    [ $? -ne 0 ] && exit 1
    echo "Server is running at ${address}"

    sed -i 's/NatsUrl=.*/NatsUrl='${address}':4222/' "${install_path}/diss-metric/diss-metric.env"
    [ $? -ne 0 ] && exit 1
    echo "Nats listen at ${address}:4222"

    sed -i 's/ANYI_FILES_REPO=.*/ANYI_FILES_REPO=https:\/\/'${address}':10443/' "${install_path}/diss-metric/diss-metric.env"
    [ $? -ne 0 ] && exit 1

    sed -i 's/ANYI_FILES_REPO=.*/ANYI_FILES_REPO=https:\/\/'${address}':10443/' "${install_path}/dc"
    [ $? -ne 0 ] && exit 1
}

setup_server() {
    local conf_tpl="${install_path}/diss-ui/config/serverConfig-tpl.js"
    local conf_file="${install_path}/diss-ui/config/dist/serverConfig.js"
    if [ ! -f "${conf_tpl}" ]; then
        echo "Damaged server package, cannot find template configure file '${conf_tpl}'"
        exit 1
    fi

    if ! cp "${conf_tpl}" "${conf_file}"; then
        echo "Copy configure file failed"
        exit 1
    fi

    sed -i 's/<!!--HOST_IP--!!>/'${address}'/' "${conf_file}"
    [ $? -ne 0 ] && echo "Setup configure file '${config_file}' failed" && exit 1

    sed -i '/\[system\]/,/^$/s/IP \{0,\}=.*/IP = '\"${address}\"'/' "${install_path}/diss-backend/conf/app.conf"
    [ $? -ne 0 ] && echo "Setup configure file '${install_path}/diss-backend/conf/app.conf' failed" && exit 1

    # setup_db
    # [ $? -ne 0 ] && exit 1
}

setup() {
    if [ -z ${address} ]; then
		stty erase '^H'
		if ! read -p "Please input server address(ip/domain): " address; then
			exit 1
		fi
	fi
	
	if ! echo ${address} | grep "^[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,23\}$" > /dev/null; then
		if ! echo ${address} | grep "^[0-9a-zA-z._-].*\.[a-zA-Z]\{1,6\}$" > /dev/null; then 
			echo "Found mal-formatted address(${address}), ipv4 or domain name required"
			exit 1
		fi
	fi

    if [ -z ${address} ]; then
        echo "Server address is required"
        exit 1
    fi

    echo "Update ${module} configures"

    case ${module} in
        agent)
            setup_agent
            ;;
        server)
            setup_server
            ;;
    esac
}

setup_rpm() {
    list_rpm_pkg="rpm -qa > /tmp/rpm-installed"
    rpm_cron_file="/etc/cron.daily/diss-rpm"

    if [[ ${host_os_id} = "centos" || ${host_os_id} = "fedora" || ${host_os_id} = "redhat" ]]; then
        if ! hash locate 2> /dev/null; then
            echo "**** NOTE ****  [System] mlocate not install, which is required to get java and jar information"
            echo "**** NOTE ****  [System] mlocate rpm pack is in tools\search-tools."
        fi
    fi

    if hash updatedb 2> /dev/null; then
        updatedb >> install.log  2>&1 &
        if [ $? -ne 0 ]; then
            echo "[NOTE] mlocate does not work, can't get some package info, please install or fix it"
        fi
    fi

    if [ -f "/etc/redhat-release" ];then
        if [ ! -f "${rpm_cron_file}" ];then
            echo ${list_rpm_pkg} > ${rpm_cron_file}
            chmod +x ${rpm_cron_file}
        fi

        echo "Get RPM packages"
        echo ${list_rpm_pkg} | awk '{run=$0;system(run)}'
    fi    
}

uninstall_image() {
    if [ $# -eq 0 ]; then
        echo "Image name is required for uninstalling operation"
        return 1
    fi

    echo ""
    images=`docker images | grep $1 | awk -F ' ' '{printf "%s:%s\n",$1,$2}'`
    test -z "${images}" && return

    for image in ${images}
    do
        if [ $1 = "scope" ]; then
            tmp=`echo $1 | grep diss`
            [ -z ${tmp} ] && return
        fi

        echo "Uninstalling image ${image}"

        containers=`docker ps -a | grep ${image} | awk -F' ' '{print $NF}'`
        if [ -n "${containers}" ]; then
            for container in ${containers}
            do
                echo "Stopping container ${container}"
                if ! docker stop ${container} > /dev/null; then
                    echo "Stopping container ${container} failed"
                fi

                echo "Removing container ${container}"
                if ! docker rm -f ${container} > /dev/null; then
                    echo "Removing container ${container} failed"
                fi
            done
        fi

        echo "Removing image ${image}"
        if ! docker rmi ${image} > /dev/null; then
            echo "Uninstalling image ${image} failed"
            continue
        fi
        echo "Uninstalling image ${image} success"
    done
}

# cleanup remove all installed and runtime generated data in host
cleanup() {
    local install_prefix=`get_config path`
    local install_path=${install_prefix}/diss-${module}-dist
    if [ -n "${install_prefix}" -a -d "${install_prefix}" ]; then
        if [ -d "${install_prefix}/images" ]; then
            for file in `ls "${install_prefix}/images"`
            do
                case ${module} in
                    agent)
                        for image in docker-bench-security kube-bench amclean diss-metric amprobe scope kube-scan
                        do
                            if [[ ${file} =~ ^"${image}".* ]]; then
                                rm -f "${install_prefix}/images/${file}"
                                break
                            fi
                        done
                        ;;
                    server)
                        for image in diss-backend diss-ui-nginx nats-streaming nginx postgres timescaledb
                        do
                            if [[ ${file} =~ ^"${image}".* ]]; then
                                rm -f "${install_prefix}/images/${file}"
                                break
                            fi
                        done
                        ;;
                esac
            done

            # remove images directory if empty
            item_count=`ls "${install_prefix}/images" | wc -l`
            [ ${item_count} -eq 0 ] && rm -fr "${install_prefix}/images"
        fi

        rm -fr "${install_path}"
        item_count=`ls "${install_prefix}" | wc -l`
        [ ${item_count} -eq 0 ] && rm -fr "${install_prefix}"
    fi

    if [ -d "${cfgpath}" ]; then
        rm -fr "${cfgpath}"

        [ ${module} = "server" -a -d "/var/lib/diss/db" ] && rm -fr "/var/lib/diss/db"

        item_count=`ls /var/lib/diss | wc -l`
        [ ${item_count} -eq 0 ] && rm -fr /var/lib/diss
    fi
}

uninstall_agent() {
    echo "Uninstall ${module} ..."
    for image in docker-bench-security kube-bench amclean diss-metric amprobe scope diss-kube-scan
    do
        uninstall_image ${image}
    done

    echo "Cleanup ${module} data"
    cleanup
}

uninstall_server() {
    echo "Uninstall ${module} ..."
    for image in diss-backend diss-ui-nginx nats-streaming postgres timescaledb
    do
        uninstall_image ${image}
    done

    echo "Cleanup ${module} data"
    cleanup
}

uninstall() {
    case ${module} in
        agent)
            uninstall_agent
            ;;
        server)
            uninstall_server
            ;;
    esac
    echo "Uninstall ${module} success"
}


prefix="/opt"
url=""
package=""
command=""
version="latest"
address=""
bashcfg="/root/.bashrc"
module="agent"
compatibility=true

if [ $# -eq 0 ]; then
    echo "Please specify a valid command to run this script"
    usage
    exit 1
fi

case $1 in
    install|uninstall|setup)
        command=$1
        ;;
    --help|-h)
        usage
        exit 0
        ;;
    *)
        echo "Found illegal command '$1'"
        usage
        exit 1
        ;;
esac
shift

while test $# -gt 0
do
    case $1 in
        --path)
            shift
            if [ $# -eq 0 ]; then
                echo "Missing value for option '--path'"
                usage
                exit 1
            fi
            prefix=$1
            ;;
        --url)
            if [ ${command} != "install" ];then
                echo "Found illegal option for command '${command}'"
                usage
                exit 1
            fi

            shift
            if [ $# -eq 0 ]; then
                echo "Missing value for option '--url'"
                usage
                exit 1
            fi

            if [[ $1 =~ ^ssh:\/\/.* || $1 =~ ^http[s]?:\/\/.* || $1 =~ ^file:\/\/.* ]]; then
                url=$1
                package=${url##*/}
                if [[ ${package} =~ .*server.* ]]; then
                    module="server"
                elif [[ ${package} =~ .*agent.* ]]; then
                    module="agent"
                else
                    module=""
                fi
            else
                echo "Found mal-formatted url '$1'"
                usage
                exit 1
            fi
            ;;
        --host)
            if [ ${command} != "setup" -a ${command} != "install" ]; then
                echo "Found illegal option '$1' for command '${command}'"
                usage
                exit 1
            fi

            shift
            if [ $# -eq 0 ]; then
                echo "Missing value for option '--host'"
                usage
                exit 1
            fi
            address=$1
            ;;
        --module)
            shift
            if [ $# -eq 0 ]; then
                echo "Missing value for option '--module'"
                usage
                exit 1
            fi

            if [ $1 != "agent" -a $1 != "server" ]; then
                echo "Found illegal valule '$1' for option '--module', only accept 'agent' and 'server'"
                usage
                exit 1
            fi
            module=$1
            ;;
        --help|-h)
            usage
            exit 0
            ;;
        *)
            echo "Found illegal option '$1' for command '${command}'"
            usage
            exit 1
            ;;
    esac
    shift
done

if [ -z ${module} ]; then
    echo "Unable to recognize diss module automatically, please specify with option '--module'"
    usage
    exit 1
fi

install_prefix="${prefix}/diss"
install_path="${prefix}/diss/diss-${module}-dist"
cfgpath="/var/lib/diss/diss-agent"

[ ${module} = "server" ] && cfgpath="/var/lib/diss/diss-backend"

check_dependency
check_host

case ${command} in
    install)
        install
        ;;
    uninstall)
        uninstall
        ;;
    setup)
        install_prefix=`get_config path`
        install_path=${install_prefix}/diss-${module}-dist
        [ -z "${install_prefix}" ] && echo "Cannot find installed ${module} package, please install again." && exit 1
        setup
        echo "Setup ${module} success"
        ;;
esac